import { FIT, FitField } from "fit-defs";

console.log(
  `// GENERATED BY:\n`,
  `// % node build/tools/generate-fit-tables.js > src/fit-tables.ts\n`
);
console.log(`export type FitRawTypes = keyof typeof fit_types;`);
console.log(
  `export type FitBaseTypes = Exclude<keyof typeof fit_types.fit_base_type, "_min"| "_max">;`
);
console.log(`export type FitTypes = FitRawTypes|FitBaseTypes;`);
console.log(
  `export type FitExtraTypes = FitTypes | "bool" | "byte_array" | "uint16_array" | "uint32_array";`
);
console.log(`export type FitField = {
    field: string;
    type: FitExtraTypes;
    scale: number | null;
    offset: number | null;
    units: string;
  };

  export type IndexedFitField = FitField & { index: number; };`);
console.log("export type FitTypeMap = Record<string, Record<string, number>>;");
console.log(
  "export type FitMessageMap = Record<string, {value:number; fields:Record<string,IndexedFitField>}>;"
);

const fit_types = Object.fromEntries(
  Object.entries(FIT.types)
    .concat([
      [
        "device_index",
        {
          0: 0,
          254: 254,
        },
      ],
    ])
    .map(([key, value]) => {
      let max = -Infinity;
      let min = Infinity;
      const mapped = Object.entries(value).map(([k, v]) => {
        const num = Number(k);
        if (isNaN(num) || num !== Math.round(num)) {
          throw new Error(`expected a number, but got "${k}"`);
        }
        if (num < min) min = num;
        if (num > max) max = num;
        return [v, num] as const;
      });
      mapped.push(["_min", min], ["_max", max]);

      return [key, Object.fromEntries(mapped)] as const;
    })
);

console.log(
  `export const fit_types = ${JSON.stringify(
    fit_types,
    undefined,
    "  "
  )} as const satisfies FitTypeMap;\n`
);

const fit_messages = Object.fromEntries(
  Object.entries(FIT.messages).map(([key, value]) => {
    const mapped = Object.entries(value)
      .filter((v): v is [string, FitField] => v[0] !== "name")
      .map(([k, v]) => {
        const num = Number(k);
        if (isNaN(num) || num !== Math.round(num)) {
          throw new Error(`expected a number, but got "${k}"`);
        }
        if ((v.offset as unknown) === "") v.offset = null;
        const scale = v.scale as unknown;
        if (typeof scale === "string") {
          const val = Number(scale.replace(",", "."));
          if (isNaN(val)) throw new Error(`Bad scale: ${scale}`);
          v.scale = val;
        }
        if ((v.type as string) === "int32") {
          v.type = "uint32";
        }
        return [v.field, { index: num, ...v }] as const;
      });
    if (!value.name) {
      throw new Error(`Missing name in key ${key}: ${JSON.stringify(value)}`);
    }
    const num = Number(key);
    if (isNaN(num) || num !== Math.round(num)) {
      throw new Error(`expected a number, but got "${key}"`);
    }

    return [
      value.name,
      { value: num, fields: Object.fromEntries(mapped) },
    ] as const;
  })
);

console.log(
  `export const fit_messages = ${JSON.stringify(
    fit_messages,
    undefined,
    "  "
  )} as const satisfies FitMessageMap;\n`
);

const base_types = Object.fromEntries(
  Object.keys(fit_types.fit_base_type)
    .concat("bool", "byte_array", "uint32_array", "uint16_array")
    .map((k) => [k, true] as const)
);

console.log(`export type FitMessageInputs = {`);
Object.entries(fit_messages).forEach(([key, value]) => {
  console.log(`  ${key}: {`);
  Object.entries(value.fields).forEach(([k, v]) => {
    const type = v.type in fit_types ? fit_types[v.type] : base_types[v.type];
    if (!type) {
      throw new Error(`Missing fit_type: ${v.type}`);
    }
    let typestr = "";
    if (v.type === "string") {
      typestr = "string";
    } else if (type === true) {
      typestr = v.type.endsWith("_array") ? "number[]" : "number";
    } else if ("mask" in type) {
      typestr = `{ value: number; options?:(${Object.keys(type)
        .filter(
          (k) =>
            k !== "mask" && k !== "_min" && k !== "_max" && isNaN(Number(k))
        )
        .map((k) => JSON.stringify(k))
        .join("|")})[]}`;
    } else {
      typestr = Object.keys(type)
        .filter((k) => k !== "_min" && k !== "_max" && isNaN(Number(k)))
        .map((k) => JSON.stringify(k))
        .join("|");
      if (typestr === "" || typestr === '"min"') typestr = "number";
    }
    console.log(`    ${k}: ${typestr};`);
  });
  console.log(`  };`);
});
console.log(`};`);
